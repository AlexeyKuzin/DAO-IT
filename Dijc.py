# -*- cofing utf-8 -*-
import json
import pathlib
import os


class Dejcstra:
    def __init__(self, g):
        self.g = g
        self.N = len(self.g)

    def set_point(self):
        global SP, FP

        while True:
            print("Пожайлуста Введите начальную точку маршрута")
            SP = input()
            if SP in self.g.keys():
                break
        print("Начальная точка маршрута назначена")

        while True:
            print("Пожайлуста Введите конечную точку маршрута:")
            FP = input()
            if FP in self.g.keys():
                break
        print("Конечная точка маршрута назначена")
        print('\nНачальная точка маршрута: ' + str(SP) + ' конечная точка маршрута: ' + str(FP))

    def dijkstra(self):
        v = SP
        e = FP
        g = self.g
        N = len(g)

        def yes_sir(v, p, t, b, e):
            for x in g[v]:  # для каждого соседа (х) текущей вершины (a)
                xm = p[v] + g[v][x]  # новая метка соседа (xm) =
                # метка текущей вершины (p[a]) +
                # значение ребра vx (g[a][x])

                if not x in p:  # если соседа (x) нет в словаре (p)
                    p[x] = xm  # записываем новую метку (xm) в словарь с ключем (x)
                    b[x] = v  # как только метка пересчитывается, запоминаем
                    # (следующая вершина: предыдущая вершина) в словаре (b)
                elif not x in t:  # иначе если (x) не в (t)
                    if p[x] > xm:  # если старая метка соседа больше новой метки
                        p[x] = xm  # новую метку записываем на место старой
                        b[x] = v  # как только метка пересчитывается, запоминаем
                        # (следующая вершина: предыдущая вершина) в словаре (b)

            t.append(v)

            if N <= len(t):  # Условие выхода из функции
                print('\nВершины и их метки =', p)
                print('Словарь для отслеживания пути =', b)

                s = []  # кратчайший путь
                s.insert(0, e)  # вставляем (е) в список (s) по индексу (0)

                while True:
                    if b[e] == -1:  # значение ключа (-1) имеет начальная вершина
                        # вот её и ищем в словаре (b)
                        print('Кратчайший путь от начальной до конечной вершины =', s)
                        print("Общий вес маршрута составил: " + str(p[FP]))
                        break  # выходим из цикла
                    e = b[e]  # теперь последней вершиной будет предыдущая
                    s.insert(0, e)  # вставляем (е) в список (s) по индексу (0)1

                return s

            for d in p:  # вершина (d) с минимальной меткой из словаря (p)
                if d not in t:
                    dm = p[d]  # метка вершины (d)
                    break  # пусть это будет первая вершина из словаря (p)

            for y in p:  # для каждой вершины (y) из словаря (p)
                if p[y] < dm and not y in t:  # если метка вершины (y) <
                    # метки вершины (d) & (y) нет в (t)
                    dm = p[y]  # метку вершины (y) записываем в (dm)
                    d = y  # вершину (y) записываем в (d)

            v = d  # теперь текущей вершиной v будет вершина d

            yes_sir(v, p, t, b, e)

        t = []
        p = {}
        p[SP] = 0
        b = {}
        b[SP] = -1
        y = yes_sir(v, p, t, b, e)
