# -*- coding utf-8 -*-
from Create_And_Read_graf import *


# -----------------Создаем и писываем заранее созданный граф в виде словаря---------------------
# Функция создает файлик и возвращает путь к нему

create_graf()

# ----------------Загружаем полученный граф-----------------------------------------------------

g = read_graf()
print(str(type(g)))
print("Граф успешно загружен")
print("Всего точек " + (str(len(g))))

# ------------------Выбираем начальный и конечный пункты маршрута-------------------------------
global SP, FP

while True:
    print("Пожайлуста Введите начальную точку маршрута")
    SP = input()
    if SP in g.keys():
        break
print("Начальная точка маршрута назначена")

while True:
    print("Пожайлуста Введите конечную точку маршрута:")
    FP = input()
    if FP in g.keys():
        break
print("Конечная точка маршрута назначена")
print('\nНачальная точка маршрута: ' + str(SP) + ' конечная точка маршрута: ' + str(FP))
N = len(g)
#------------------Пишем функцию Дейкстры--------------------------------------------

def dijkstra(v, p, t, b, e):
    for x in g[v]:  # для каждого соседа (х) текущей вершины (a)
        xm = p[v] + g[v][x]  # новая метка соседа (xm) =
        # метка текущей вершины (p[a]) +
        # значение ребра vx (g[a][x])

        if not x in p:  # если соседа (x) нет в словаре (p)
            p[x] = xm  # записываем новую метку (xm) в словарь с ключем (x)
            b[x] = v  # как только метка пересчитывается, запоминаем
            # (следующая вершина: предыдущая вершина) в словаре (b)
        elif not x in t:  # иначе если (x) не в (t)
            if p[x] > xm:  # если старая метка соседа больше новой метки
                p[x] = xm  # новую метку записываем на место старой
                b[x] = v  # как только метка пересчитывается, запоминаем
                # (следующая вершина: предыдущая вершина) в словаре (b)

    t.append(v)

    if N <= len(t):  # Условие выхода из функции
        print('\nВершины и их метки =', p)
        print('Словарь для отслеживания пути =', b)

        s = []  # кратчайший путь
        s.insert(0, e)  # вставляем (е) в список (s) по индексу (0)

        while True:
            if b[e] == -1:  # значение ключа (-1) имеет начальная вершина
                # вот её и ищем в словаре (b)
                print('Кратчайший путь от начальной до конечной вершины =', s)
                print("Общий вес маршрута составил: " + str(p[FP]))
                break  # выходим из цикла
            e = b[e]  # теперь последней вершиной будет предыдущая
            s.insert(0, e)  # вставляем (е) в список (s) по индексу (0)1

        return s

    for d in p:  # вершина (d) с минимальной меткой из словаря (p)
        if d not in t:
            dm = p[d]  # метка вершины (d)
            break  # пусть это будет первая вершина из словаря (p)

    for y in p:  # для каждой вершины (y) из словаря (p)
        if p[y] < dm and not y in t:  # если метка вершины (y) <
            # метки вершины (d) & (y) нет в (t)
            dm = p[y]  # метку вершины (y) записываем в (dm)
            d = y  # вершину (y) записываем в (d)


    v = d  # теперь текущей вершиной v будет вершина d


    dijkstra(v, p, t, b, e)

#----------------Вызываем функцию Дейкстры----------------------------------------

t = []
p = {}
p[SP] = 0
b = {}
b[SP] = -1


Dejk = dijkstra(SP, p, t, b, FP)

